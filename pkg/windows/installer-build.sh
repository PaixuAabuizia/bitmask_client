#!/bin/bash

# build installer
# ===============
#
# builds several installers from previously compiled binaries

product=bitmask
# the location of the nsis installer nis files dictates the path of the files
relative_executable_path=../../build/executables
source_ro_path=/var/src/${product}
temporary_build_path=/var/tmp/installer

setups=($(ls -1 ${source_ro_path}/pkg/windows | grep '.nis$' | sed 's|.nis$||'))

# generate nsis file references for installer for single directory
# appends File and Remove to files that are later included by makensis
# separate files for install and uninstall statements
#
# directory_root: the tree root that is currently generated
# subdir: any directory in the tree
# setup_name: the name of the setup this nsh entries are generated for
function generateDirectoryNSISStatements() {
  directory_root=$1
  subdir=$2
  setup_name=$3
  find ${subdir} -maxdepth 1 -type f -exec echo 'File "'${relative_executable_path}'/{}"' \;>> ${setup_name}_install_files.nsh
  find ${subdir} -maxdepth 1 -type f -exec echo 'Delete "$INSTDIR/{}"' \;  >> ${setup_name}_uninstall_files.nsh
}
# generate a tree of files into nsis installer definitions
# directory_root: the tree root that is currently generated
# setup_name: the name of the setup this nsh entries are generated for
function generateDirectoryNSISStatementsTree() {
  directory_root=$1
  setup_name=$2
  subdirs=$(find ${directory_root} -type d | sort)
  for subdir in ${subdirs[@]}
  do
    if [ "${directory_root}" != "${subdir}" ]; then
      echo 'SetOutPath "$INSTDIR/'${subdir}'"' >> ${setup_name}_install_files.nsh
    fi
    generateDirectoryNSISStatements ${directory_root} ${subdir} ${setup_name}
  done
  # again to remove emptied directories on uninstall so reverse
  subdirs=$(find ${directory_root} -type d | sort | tac)
  for subdir in ${subdirs[@]}
  do
    if [ "${directory_root}" != "${subdir}" ]; then
      echo 'RMDir "$INSTDIR/'${subdir}'"' >> ${setup_name}_uninstall_files.nsh
    fi
  done
}
# generate installer files for the available setups
# those files include install and uninstall statements and are
# modified (backslashes/source_path) to generate a sane target
# structure
function generateNSISStatements() {
  pushd ${temporary_build_path}/build/executables
  for setup in "${setups[@]}"
  do
    echo "setup:" ${setup}
    echo "# auto generated by pkg/windows/installer-build.sh please do not modify" > ${setup}_install_files.nsh
    echo "# auto generated by pkg/windows/installer-build.sh please do not modify" > ${setup}_uninstall_files.nsh
    setup_source_path=${setup}
    generateDirectoryNSISStatementsTree ${setup_source_path} ${setup}
    # remove the setup_source_path from the nsh files
    sed -i "s|INSTDIR/${setup_source_path}/|INSTDIR/|" ${setup}_install_files.nsh
    sed -i "s|/${setup_source_path}/|/|" ${setup}_uninstall_files.nsh
    # make backslashes
    sed -i "s|/|\\\\|g" ${setup}_install_files.nsh ${setup}_uninstall_files.nsh
    # make install size
    installed_size=$(du -s --block-size=1000 ${setup} | awk '{print $1}')
    echo "!define INSTALLSIZE ${installed_size}" > ${setup}_install_files_size.nsh
  done
  popd
}
# makensis to produce a installer.exe
# the result is placed in /var/dist
function buildInstaller() {
  pushd ${temporary_build_path}/pkg/windows
  for setup in ${setups[@]}
  do
    makensis ${setup}.nis || die 'build setup "'${setup}'" failed'
  done
  popd
}
# prepare build path
# copies files that have been produced by other containers
# merges the product so the nsis files are correct
function prepareBuildPath() {
	mkdir -p ${temporary_build_path}/pkg/windows
	mkdir -p ${temporary_build_path}/build
	cp -r ${source_ro_path}/pkg/windows/* ${temporary_build_path}/pkg/windows
	cp -r ${source_ro_path}/build/* ${temporary_build_path}/build
	cp -r ${source_ro_path}/LICENSE ${temporary_build_path}/LICENSE

  test -d ${temporary_build_path}/build/executables/bitmask || die 'bitmask not available run docker-compose run --rm pyinstaller'
  test -d ${temporary_build_path}/build/executables/openvpn || die 'openvpn not available run docker-compose run --rm openvpn'
  pushd ${temporary_build_path}/build/executables
  cp openvpn/bin/openvpn.exe bitmask
  cp openvpn/bin/*.dll bitmask
  popd
}
# remove build files to ensure subsequent builds
function cleanup() {
	rm -r ${temporary_build_path}
}
# display failure message and emit non-zero exit code
function die() {
  echo "die:" $@
  exit 1
}
function main() {
  prepareBuildPath
  generateNSISStatements
  buildInstaller
  cleanup
}
main $@