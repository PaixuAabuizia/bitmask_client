#!/bin/bash

# build installer
# ===============
#
# builds several installers from previously compiled binaries

product=bitmask
# the location where the pyinstaller results are placed
absolute_executable_path=/var/build/executables
# the location of the nsis installer nis files dictates the path of the files
relative_executable_path=../../build/executables
source_ro_path=/var/src/${product}
temporary_build_path=/var/tmp/${product}

setups=($(ls -1 ${source_ro_path}/pkg/windows | grep '.nis$' | sed 's|.nis$||'))



# generate nsis file references for installer for single directory
# appends File and Remove to files that are later included by makensis
# separate files for install and uninstall statements
#
# directory_root: the tree root that is currently generated
# subdir: any directory in the tree
# setup_name: the name of the setup this nsh entries are generated for
function generateDirectoryNSISStatements() {
  directory_root=$1
  subdir=$2
  setup_name=$3
  find ${subdir} -maxdepth 1 -type f -exec echo 'File "'${relative_executable_path}'/{}"' \;>> ${setup_name}_install_files.nsh
  find ${subdir} -maxdepth 1 -type f -exec echo 'Delete "$INSTDIR/{}"' \;  >> ${setup_name}_uninstall_files.nsh
}
# generate a tree of files into nsis installer definitions
# directory_root: the tree root that is currently generated
# setup_name: the name of the setup this nsh entries are generated for
function generateDirectoryNSISStatementsTree() {
  directory_root=$1
  setup_name=$2
  subdirs=$(find ${directory_root} -type d | sort)
  for subdir in ${subdirs[@]}
  do
    if [ "${directory_root}" != "${subdir}" ]; then
      echo 'SetOutPath "$INSTDIR/'${subdir}'"' >> ${setup_name}_install_files.nsh
    fi
    generateDirectoryNSISStatements ${directory_root} ${subdir} ${setup_name}
  done
  # again to remove emptied directories on uninstall so reverse
  subdirs=$(find ${directory_root} -type d | sort | tac)
  for subdir in ${subdirs[@]}
  do
    if [ "${directory_root}" != "${subdir}" ]; then
      echo 'RMDir "$INSTDIR/'${subdir}'"' >> ${setup_name}_uninstall_files.nsh
    fi
  done
}
# generate installer files for the available setups
# those files include install and uninstall statements and are
# modified (backslashes/source_path) to generate a sane target
# structure
function generateNSISStatements() {
  pushd ${temporary_build_path}/build/executables
  for setup in "${setups[@]}"
  do
    echo "setup:" ${setup}
    echo "# auto generated by pkg/windows/installer-build.sh please do not modify" > ${setup}_install_files.nsh
    echo "# auto generated by pkg/windows/installer-build.sh please do not modify" > ${setup}_uninstall_files.nsh
    setup_source_path=${setup}
    generateDirectoryNSISStatementsTree ${setup_source_path} ${setup}
    # remove the setup_source_path from the nsh files
    sed -i "s|INSTDIR/${setup_source_path}/|INSTDIR/|" ${setup}_install_files.nsh
    sed -i "s|/${setup_source_path}/|/|" ${setup}_uninstall_files.nsh
    # make backslashes
    sed -i "s|/|\\\\|g" ${setup}_install_files.nsh ${setup}_uninstall_files.nsh
    # make install size
    installed_size=$(du -s --block-size=1000 ${setup} | awk '{print $1}')
    echo "!define INSTALLSIZE ${installed_size}" > ${setup}_install_files_size.nsh
  done
  popd
}
function buildInstaller() {
  pushd ${temporary_build_path}/pkg/windows
  for setup in ${setups[@]}
  do
    makensis ${setup}.nis
  done
  popd
}
function prepareBuildPath() {
	mkdir -p ${temporary_build_path}/pkg/windows
	mkdir -p ${temporary_build_path}/build
	cp -r ${source_ro_path}/pkg/windows/* ${temporary_build_path}/pkg/windows
	cp -r ${source_ro_path}/build/* ${temporary_build_path}/build
	cp -r ${source_ro_path}/LICENSE ${temporary_build_path}/LICENSE
}
function cleanup() {
	rm -r ${temporary_build_path}
}

function main() {
  prepareBuildPath
  generateNSISStatements
  buildInstaller
  #cleanup
}
main $@